# backtesting/backtester.py
import pandas as pd
import os
from datetime import datetime
from decimal import Decimal, ROUND_HALF_UP 
import logging 

# Import our strategy and configuration
from core.strategy import GridStrategy 
from config.parameters import GRID_STRATEGY_PARAMS, INITIAL_BACKTEST_CAPITAL, COMMISSION_RATE
from config.settings import KRAKEN_MIN_ORDER_SIZES 

class Backtester:
    def __init__(self, data_folder='backtesting/data/raw/', 
                 initial_capital=INITIAL_BACKTEST_CAPITAL, 
                 commission_rate=COMMISSION_RATE,
                 min_order_sizes_map=KRAKEN_MIN_ORDER_SIZES): 
        
        self.data_folder = data_folder
        self.initial_capital = initial_capital 
        self.commission_rate = Decimal(str(commission_rate)) 
        self.min_order_sizes = min_order_sizes_map 
        
        self.market_data = {} 
        self.strategies = {} 
        
        self.portfolio = {
            'cash': Decimal(str(initial_capital)), 
            'crypto_holdings': {}, 
        }
        self.trade_log = [] 
        self.equity_curve = [] 
        self.current_time = None
        self.current_price = None 

        self.highest_equity_peak = Decimal('0') 
        self.global_max_drawdown_percentage = Decimal(str(GRID_STRATEGY_PARAMS["global_max_drawdown_percentage"]))
        
        self.initial_deployed_equity = Decimal('0') 

        self.debug_logger = logging.getLogger('backtest_debug')
        self.debug_logger.setLevel(logging.DEBUG)
        logs_dir = 'logs'
        if not os.path.exists(logs_dir):
            os.makedirs(logs_dir)
        debug_log_filepath = os.path.join(logs_dir, f"backtest_debug_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
        
        if not self.debug_logger.handlers:
            file_handler = logging.FileHandler(debug_log_filepath)
            formatter = logging.Formatter('%(asctime)s - %(message)s')
            file_handler.setFormatter(formatter)
            self.debug_logger.addHandler(file_handler)
        self.debug_logger.propagate = False 
        print(f"Verbose debug log saved to: {debug_log_filepath}") 


    def load_data(self, symbol_pair, timeframe='1m'):
        filename = f"{symbol_pair}_{timeframe}.csv"
        filepath = os.path.join(self.data_folder, filename)
        
        if not os.path.exists(filepath):
            print(f"Error: Data file not found for {symbol_pair} at {filepath}")
            return False

        print(f"Loading data for {symbol_pair} from {filepath}...")
        df = pd.read_csv(filepath)
        
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df.set_index('timestamp', inplace=True)
        
        # Convert relevant columns to Decimal for precision
        df['open'] = df['open'].apply(lambda x: Decimal(str(x)))
        df['high'] = df['high'].apply(lambda x: Decimal(str(x)))
        df['low'] = df['low'].apply(lambda x: Decimal(str(x)))
        df['close'] = df['close'].apply(lambda x: Decimal(str(x)))
        df['volume'] = df['volume'].apply(lambda x: Decimal(str(x)))

        if df.empty:
            print(f"Warning: Loaded an empty DataFrame for {symbol_pair}.")
            return False
        
        self.market_data[symbol_pair] = df
        print(f"Loaded {len(df)} candles for {symbol_pair}.")
        return True

    def run_backtest(self, symbol_pair): 
        if symbol_pair not in self.market_data:
            print(f"Error: Data for {symbol_pair} not loaded. Please call load_data() first.")
            return

        print(f"\n--- Starting Backtest for {symbol_pair} ---")
        data = self.market_data[symbol_pair]
        
        strategy_params_for_symbol = GRID_STRATEGY_PARAMS.copy()
        strategy_params_for_symbol["symbol"] = symbol_pair 
        
        strategy_instance = GridStrategy(strategy_params_for_symbol)
        self.strategies[symbol_pair] = strategy_instance 

        # Set Backtester's initial current_time and current_price based on the first candle
        first_timestamp, first_candle = list(data.iloc[0:1].iterrows())[0]
        self.current_time = first_timestamp
        self.current_price = first_candle['close']
        
        # Inject context into the strategy
        strategy_instance.set_backtester_context(
            self.portfolio, 
            self._execute_order, 
            self.commission_rate, 
            self.min_order_sizes
        )
        
        # Pass the initial price for grid calculation
        strategy_instance.calculate_grid_levels(self.current_price) 
        
        # Initial order placement for the strategy. Strategy also needs initial price.
        strategy_instance.current_price = self.current_price 
        strategy_instance._place_initial_orders()
        
        # --- CRITICAL: RECORD INITIAL EQUITY AFTER SETUP AND SET HIGHEST_EQUITY_PEAK ---
        initial_equity_after_setup = self.portfolio['cash'] + \
                                     self.portfolio['crypto_holdings'].get(symbol_pair.split('_')[0], Decimal('0')) * self.current_price
        
        self.initial_deployed_equity = initial_equity_after_setup 
        
        self.highest_equity_peak = initial_equity_after_setup 
        self._record_equity(symbol_pair, self.current_price) 
        
        self.debug_logger.debug(f"Initial equity after setup: {initial_equity_after_setup:,.2f}")
        self.debug_logger.debug(f"Initial highest_equity_peak (for global drawdown): {self.highest_equity_peak:,.2f}")
        self.debug_logger.debug(f"Global Drawdown target (20% from peak): {self.highest_equity_peak * (Decimal('1') - self.global_max_drawdown_percentage):,.2f}")

        backtest_halted_by_drawdown = False 

        # Main backtest loop (start from the *second* candle)
        for i, (timestamp, candle) in enumerate(data.iloc[1:].iterrows()): 
            self.current_time = timestamp 
            current_price = candle['close'] 
            
            # 1. Update holdings based on previous candle's fills and strategy actions
            self._check_for_fills(symbol_pair, candle, strategy_instance)
            strategy_instance.on_candle(symbol_pair, candle, current_price, self.current_time)
            
            # 2. Calculate current equity after all actions for this candle are considered
            current_equity_for_check = self.portfolio['cash'] + \
                                       self.portfolio['crypto_holdings'].get(symbol_pair.split('_')[0], Decimal('0')) * current_price
            
            # 3. Update highest peak
            if current_equity_for_check > self.highest_equity_peak: 
                self.highest_equity_peak = current_equity_for_check

            # 4. Record equity in the curve
            self._record_equity(symbol_pair, current_price) 

            # 5. Perform drawdown check
            drawdown_threshold = self.highest_equity_peak * (Decimal('1') - self.global_max_drawdown_percentage)
            self.debug_logger.debug(f"Candle {self.current_time}: Equity: {current_equity_for_check:,.2f}, Peak: {self.highest_equity_peak:,.2f}, Threshold: {drawdown_threshold:,.2f}")

            if current_equity_for_check < drawdown_threshold:
                self.debug_logger.critical(f"\n!!! GLOBAL MAX DRAWDOWN TRIGGERED at {self.current_time} !!!") 
                self.debug_logger.critical(f"Equity: {current_equity_for_check:,.2f}, Peak: {self.highest_equity_peak:,.2f}, Max Allowed Drawdown: {self.global_max_drawdown_percentage*100:.2f}%")
                
                # Simulate liquidation
                base_currency = symbol_pair.split('_')[0]
                if self.portfolio['crypto_holdings'].get(base_currency, Decimal('0')) > Decimal('0'):
                    self.debug_logger.critical(f"Simulating liquidation of {self.portfolio['crypto_holdings'][base_currency]:.8f} {base_currency} at {current_price:.2f} to stop losses.")
                    self._execute_order(symbol_pair, 'sell', current_price, self.portfolio['crypto_holdings'][base_currency])
                
                # Record final equity point after liquidation
                self._record_equity(symbol_pair, current_price) 
                
                self.debug_logger.critical("Backtest halted due to global max drawdown.")
                print("Backtest halted due to global max drawdown. Check debug log for details.") 
                backtest_halted_by_drawdown = True 
                break 

            if i % 1000 == 0: 
                total_equity_at_progress_point = self.equity_curve[-1]['equity'] 
                print(f"Processing candle: {self.current_time} - Current Equity: {total_equity_at_progress_point:,.2f}")

        print("\n--- Backtest Finished ---")
        self.generate_report(symbol_pair, backtest_halted_by_drawdown) 

    def _execute_order(self, symbol, order_type, price_decimal, amount_decimal):
        """
        Simulates the execution of an order (buy or sell).
        Updates the portfolio cash and crypto holdings, and records the trade.
        Returns True if successful, False otherwise (e.g., insufficient funds/holdings).
        """
        cost_decimal = price_decimal * amount_decimal
        commission_decimal = cost_decimal * self.commission_rate 
        
        base_currency = symbol.split('_')[0] 
        
        if amount_decimal <= Decimal('0'):
            self.debug_logger.warning(f"[{self.current_time.strftime('%Y-%m-%d %H:%M')}] EXEC FAILED: Zero or negative amount requested for {order_type} {symbol}. Amount: {amount_decimal:.8f}")
            return False

        if order_type == 'buy':
            if self.portfolio['cash'] >= cost_decimal + commission_decimal:
                self.portfolio['cash'] -= (cost_decimal + commission_decimal)
                self.portfolio['crypto_holdings'][base_currency] = self.portfolio['crypto_holdings'].get(base_currency, Decimal('0')) + amount_decimal
                self.trade_log.append({
                    'timestamp': self.current_time,
                    'symbol': symbol,
                    'type': 'BUY',
                    'price': float(price_decimal), 
                    'amount': float(amount_decimal),
                    'cost': float(cost_decimal),
                    'commission': float(commission_decimal),
                    'pnl': float(-commission_decimal) 
                })
                print(f"[{self.current_time.strftime('%Y-%m-%d %H:%M')}] EXEC: BUY {amount_decimal:.8f} {base_currency} @ {price_decimal:.2f} (Cash: {self.portfolio['cash']:.2f}, {base_currency}: {self.portfolio['crypto_holdings'].get(base_currency, Decimal('0')):.8f})")
                return True 
            else:
                self.debug_logger.warning(f"[{self.current_time.strftime('%Y-%m-%d %H:%M')}] EXEC FAILED: Insufficient cash for BUY {amount_decimal:.8f} {symbol}. Needed: {cost_decimal + commission_decimal:.2f}, Have: {self.portfolio['cash']:.2f}")
                return False 
        elif order_type == 'sell':
            if self.portfolio['crypto_holdings'].get(base_currency, Decimal('0')) >= amount_decimal:
                self.portfolio['cash'] += (cost_decimal - commission_decimal)
                self.portfolio['crypto_holdings'][base_currency] -= amount_decimal
                self.trade_log.append({
                    'timestamp': self.current_time,
                    'symbol': symbol,
                    'type': 'SELL',
                    'price': float(price_decimal),
                    'amount': float(amount_decimal),
                    'revenue': float(cost_decimal),
                    'commission': float(commission_decimal),
                    'pnl': float(cost_decimal - commission_decimal) 
                })
                print(f"[{self.current_time.strftime('%Y-%m-%d %H:%M')}] EXEC: SELL {amount_decimal:.8f} {base_currency} @ {price_decimal:.2f} (Cash: {self.portfolio['cash']:.2f}, {base_currency}: {self.portfolio['crypto_holdings'].get(base_currency, Decimal('0')):.8f})")
                return True 
            else:
                self.debug_logger.warning(f"[{self.current_time.strftime('%Y-%m-%d %H:%M')}] EXEC FAILED: Insufficient crypto for SELL {amount_decimal:.8f} {symbol}. Needed: {amount_decimal:.8f}, Have: {self.portfolio['crypto_holdings'].get(base_currency, Decimal('0')):.8f}")
                return False 
        return False


    def _check_for_fills(self, symbol, candle, strategy_instance):
        """
        Checks if any active orders from the strategy would have been filled by the current candle's price action.
        Notifies the strategy of fills.
        """
        filled_orders = [] 
        
        # Check Buy Orders (fill if candle's low <= order price)
        for order in strategy_instance.active_buy_orders[:]: 
            order_price = order['price'] 
            
            if candle['low'] <= order_price:
                if self._execute_order(order['symbol'], order['type'], order_price, order['amount']):
                    filled_orders.append(order)
        
        # Check Sell Orders (fill if candle's high >= order price)
        for order in strategy_instance.active_sell_orders[:]: 
            order_price = order['price'] 
            
            if candle['high'] >= order_price:
                if self._execute_order(order['symbol'], order['type'], order_price, order['amount']):
                    filled_orders.append(order)

        # Notify the strategy of all filled orders after processing all checks for the current candle.
        for filled_order in filled_orders:
            strategy_instance.notify_order_filled(filled_order)


    def _record_equity(self, symbol, current_price_decimal):
        """
        Calculates and records the total portfolio equity at the current timestamp.
        """
        base_currency = symbol.split('_')[0]
        
        crypto_value = self.portfolio['crypto_holdings'].get(base_currency, Decimal('0')) * current_price_decimal
        
        total_equity = self.portfolio['cash'] + crypto_value
        
        self.equity_curve.append({
            'timestamp': self.current_time,
            'equity': float(total_equity), 
            'cash': float(self.portfolio['cash']),
            'crypto_value': float(crypto_value)
        })

    def generate_report(self, symbol_pair, was_halted=False): 
        """
        Generates and prints a backtest report, and plots the equity curve.
        """
        if not self.trade_log:
            print("No trades executed during backtest.")
            return

        trades_df = pd.DataFrame(self.trade_log)
        equity_df = pd.DataFrame(self.equity_curve).set_index('timestamp')

        # --- CONSOLE REPORT ---
        report_output = []
        report_output.append(f"\n--- Backtest Report for {symbol_pair} ---")
        report_output.append(f"Overall Initial Capital: ${self.initial_capital:,.2f}") 
        
        final_equity = equity_df['equity'].iloc[-1]
        report_output.append(f"Final Overall Equity: ${final_equity:,.2f}")
        report_output.append(f"Overall Net PnL (from Initial Capital): ${final_equity - self.initial_capital:,.2f}")
        
        report_output.append(f"Strategy Deployed Capital: ${float(self.initial_deployed_equity):,.2f}") 
        report_output.append(f"Net PnL on Deployed Capital: ${final_equity - float(self.initial_deployed_equity):,.2f}")
        
        # Calculate ROI
        net_pnl_deployed = final_equity - float(self.initial_deployed_equity)
        roi_percentage = (net_pnl_deployed / float(self.initial_deployed_equity)) * 100 if float(self.initial_deployed_equity) != 0 else 0
        report_output.append(f"ROI on Deployed Capital: {roi_percentage:.2f}%")


        report_output.append(f"Total Trades: {len(trades_df)}")

        total_commissions = trades_df['commission'].sum()
        report_output.append(f"Total Commissions Paid: ${total_commissions:,.2f}")

        initial_equity_for_drawdown_calc = equity_df['equity'].iloc[0] 
        equity_series_for_drawdown = pd.Series([initial_equity_for_drawdown_calc] + equity_df['equity'].tolist(), 
                                               index=[equity_df.index[0] - pd.Timedelta(seconds=1)] + equity_df.index.tolist())
        
        peak = equity_series_for_drawdown.expanding(min_periods=1).max()
        drawdown = (equity_series_for_drawdown - peak) / peak
        max_drawdown = drawdown.min()
        report_output.append(f"Maximum Drawdown (from Deployed Capital): {max_drawdown * 100:.2f}%")

        winning_trades = trades_df[trades_df['pnl'] > 0]
        win_rate = len(winning_trades) / len(trades_df) if len(trades_df) > 0 else 0
        report_output.append(f"Win Rate (per leg): {win_rate * 100:.2f}%")

        for line in report_output:
            print(line)

        # --- PLOTTING EQUITY CURVE ---
        import matplotlib.pyplot as plt

        plt.figure(figsize=(14, 7)) 
        plt.plot(equity_df.index, equity_df['equity'], label='Equity Curve', color='blue')
        plt.title(f'Equity Curve for {symbol_pair} Grid Strategy Backtest')
        plt.xlabel('Time')
        plt.ylabel('Equity ($)')
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.legend()
        plt.tight_layout()
        
        plt.show() 

        # --- SAVE REPORT TO FILE ---
        reports_dir = 'reports'
        if not os.path.exists(reports_dir):
            os.makedirs(reports_dir)
        
        report_filename = os.path.join(reports_dir, f"backtest_report_{symbol_pair}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt")
        
        with open(report_filename, 'w') as f:
            for line in report_output:
                f.write(line + "\n")
            f.write("\n") 
            f.write("--- Trade Log ---\n")
            f.write(trades_df.to_string() + "\n") 
            f.write(f"\n--- Backtest Status: {'HALTED by Global Drawdown' if was_halted else 'COMPLETED Full Data'}. ---") 

        print(f"Report saved to {report_filename}")





# config/parameters.py

# --- GENERAL BOT SETTINGS ---
BOT_NAME = "MyCryptoGridBot"
INITIAL_BACKTEST_CAPITAL = 1000.0 # USD
COMMISSION_RATE = 0.004 # e.g., 0.4% Taker fee on Kraken (conservative)

# --- GRID STRATEGY PARAMETERS ---
GRID_STRATEGY_PARAMS = {
    "symbols": [
        "BTC_USD", "ETH_USD", "SOL_USD", "ADA_USD", 
        "DOT_USD", "AVAX_USD", "ATOM_USD", "LINK_USD", "XRP_USD"
    ],
    
    # Static Grid Sizing Parameters (These are now placeholders; dynamic calculation will override)
    "grid_lower_bound": 80000.0, 
    "grid_upper_bound": 90000.0, 
    
    # Dynamic Grid Sizing Parameters (These will be used by the dynamic grid logic)
    "atr_period": 14, # Period for ATR calculation (e.g., 14 candles)
    "grid_atr_multiplier": 20.0, # How many times ATR to use for total grid width
                                 # We will set this to 6.0 after this fix is applied if desired.
    "grid_center_deviation_percentage": 0.0, # Optional: For a static percentage deviation from current price if not using ATR

    "number_of_grids": 10, # Initial number of grids. Will define density within ATR range.
                            # We will set this to 5 after this fix is applied if desired.
    
    # Capital Allocation Settings (CRITICAL: All parameters needed here)
    "max_capital_allocation_percentage": 1.0, # Percentage of INITIAL_BACKTEST_CAPITAL to deploy
    "amount_per_grid_order_usd": 50.0, # Target USD amount per individual grid order
    "max_concurrent_orders_per_side": 5, # Maximum number of active buy/sell orders at any time

    "profit_per_grid_percentage": 0.02, # Target profit percentage per grid level move (e.g., 0.02 for 2%)
    
    "initial_position_type": "neutral", # How the bot initializes its position ('neutral', 'cash_only')
    "initial_long_position_amount_usd": 0.0, # If starting with specific crypto amount (not used by 'neutral' type)

    "global_max_drawdown_percentage": 0.20, # Global stop loss percentage from peak equity
}




# config/settings.py

# --- GENERAL BOT LOGGING & NOTIFICATION SETTINGS ---
LOG_LEVEL = "INFO" # Options: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_FILE = "logs/bot.log"
NOTIFY_TELEGRAM = False # Set to True to enable Telegram notifications (requires setup)
TELEGRAM_BOT_TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"
TELEGRAM_CHAT_ID = "YOUR_TELEGRAM_CHAT_ID"

# --- EXCHANGE-SPECIFIC SETTINGS (for Kraken) ---
# Minimum order sizes for various base assets on Kraken (in base asset units)
# These are crucial for ensuring orders are valid.
# ALWAYS VERIFY THESE ON KRAKEN'S OFFICIAL MINIMUM ORDER SIZE PAGE!
KRAKEN_MIN_ORDER_SIZES = {
    'BTC': 0.0001,
    'ETH': 0.005,
    'SOL': 0.1,
    'ADA': 1.0,
    'DOT': 1.0,
    'AVAX': 0.1,
    'ATOM': 1.0,
    'LINK': 1.0,
    'XRP': 10.0,
    # Add more assets if needed, ensure the 'base' part of 'PAIR_USD' is the key
}

# Add any other global settings here as needed, e.g., database paths, etc.
# DB_PATH = "data/trade_history.db" # Example



# core/strategy.py
import pandas as pd
import math
from decimal import Decimal, ROUND_HALF_UP 
from datetime import datetime, timedelta
import pandas_ta as ta # Import pandas_ta for ATR calculation

class GridStrategy:
    def __init__(self, params):
        self.symbol = params["symbol"] 
        self.config_params = params 

        self.grid_lower_bound = None 
        self.grid_upper_bound = None 
        self.grid_levels = [] # Stores current dynamic grid levels
        
        # active_buy_orders / active_sell_orders: Orders that the strategy *intends* to have open and *were successfully placed*.
        # They store grid_level_idx which must correspond to the *current* self.grid_levels
        self.active_buy_orders = [] 
        self.active_sell_orders = [] 

        self.portfolio = None # Context from Backtester (will hold Decimal values)
        self.execute_order_func = None # The backtester's simulated order execution function
        self.commission_rate = None # Will be Decimal
        self.min_order_sizes = {} # e.g., {'BTC': Decimal('0.0001'), ...}
        
        self.current_price = None # Will be Decimal
        
        # Parameters for Dynamic Grid (ATR)
        self.atr_period = params.get("atr_period", 14)
        self.grid_atr_multiplier = Decimal(str(params.get("grid_atr_multiplier", 3.0))) 
        self.ohlcv_history = pd.DataFrame() # To store recent OHLCV for ATR calculation


    def set_backtester_context(self, portfolio, execute_order_func, commission_rate, min_order_sizes_map):
        """
        Sets the necessary context from the backtester for the strategy to operate.
        """
        self.portfolio = portfolio
        self.execute_order_func = execute_order_func
        self.commission_rate = Decimal(str(commission_rate)) 
        
        self.min_order_sizes = {k: Decimal(str(v)) for k, v in min_order_sizes_map.items()}


    def calculate_grid_levels(self, initial_price):
        """
        For dynamic grid, this method will primarily prepare initial data if needed.
        The actual grid levels will be calculated dynamically on each candle in _recalculate_dynamic_grid.
        This method is called once at the start of the backtest.
        """
        # In a dynamic ATR grid, the grid levels are not calculated here.
        # They are computed in _recalculate_dynamic_grid which is called by on_candle.
        pass


    def _calculate_amount_for_order(self, symbol_pair, price_decimal):
        """
        Calculates the base asset amount for an order based on target USD value,
        and checks against exchange minimum order sizes.
        """
        target_usd_amount = Decimal(str(self.config_params["amount_per_grid_order_usd"])) 
        
        if price_decimal <= Decimal('0'): 
            return Decimal('0')
        
        base_asset_amount = (target_usd_amount / price_decimal).quantize(Decimal('0.00000001'), rounding=ROUND_HALF_UP) 
        
        base_currency = symbol_pair.split('_')[0] 
        min_size = self.min_order_sizes.get(base_currency, Decimal('0')) 
        
        if base_asset_amount < min_size:
            return Decimal('0') 

        return base_asset_amount

    def _place_initial_orders(self):
        """
        Handles initial portfolio balancing for 'neutral' grid setups,
        aiming for full deployment of allocated capital by buying a larger initial crypto proportion.
        """
        if self.current_price is None:
            print(f"[{self.symbol}] Warning: current_price not set before _place_initial_orders. Cannot place initial orders.")
            return

        if self.config_params["initial_position_type"] == "neutral":
            max_allocated_capital_for_strategy = Decimal(str(self.config_params["max_capital_allocation_percentage"])) * self.portfolio['cash']
            
            initial_crypto_proportion = Decimal('0.90') 
            
            target_crypto_usd_value_initial = max_allocated_capital_for_strategy * initial_crypto_proportion
            
            base_currency = self.symbol.split('_')[0]
            current_crypto_usd_value = self.portfolio['crypto_holdings'].get(base_currency, Decimal('0')) * self.current_price

            amount_to_buy_usd = target_crypto_usd_value_initial - current_crypto_usd_value
            
            if amount_to_buy_usd > Decimal('0'):
                initial_buy_amount = (amount_to_buy_usd / self.current_price).quantize(Decimal('0.00000001'), rounding=ROUND_HALF_UP)
                
                min_size = self.min_order_sizes.get(base_currency, Decimal('0'))
                if initial_buy_amount < min_size:
                    initial_buy_amount = min_size
                    print(f"[{self.symbol}] Adjusting initial buy to minimum size: {initial_buy_amount:.8f} {base_currency}")

                required_cash = self.current_price * initial_buy_amount * (Decimal('1') + self.commission_rate)
                if self.portfolio['cash'] >= required_cash:
                    if self.execute_order_func(self.symbol, 'buy', self.current_price, initial_buy_amount):
                        print(f"[{self.symbol}] Executing initial BUY to balance portfolio (full deployment): {initial_buy_amount:.8f} {base_currency} @ {self.current_price:.2f}")
                    else:
                        print(f"[{self.symbol}] Initial balancing BUY FAILED unexpectedly (funds checked, but _execute_order_func reported failure).")
                else:
                    print(f"[{self.symbol}] Warning: Not enough cash ({self.portfolio['cash']:.2f}) to execute initial balancing buy ({required_cash:.2f}). Starting grid with cash bias.")
            else:
                print(f"[{self.symbol}] No initial balancing buy needed. Current crypto value: {current_crypto_usd_value:.2f} USD.")


        # Initial grid orders are now managed by _manage_grid_orders, called by on_candle for the first time.
        pass


    def _recalculate_dynamic_grid(self, current_price_decimal):
        """
        Calculates ATR and dynamically adjusts grid levels based on current market conditions.
        This method replaces the static grid calculation.
        """
        if len(self.ohlcv_history) < self.atr_period:
            self.grid_levels = [] # Clear grid if not enough data for ATR
            return 
        
        # Ensure OHLCV columns are numeric for pandas_ta, and then convert to float
        # pandas_ta requires floats for calculation, convert back to Decimal after.
        atr_series = ta.atr(self.ohlcv_history['high'].astype(float), 
                            self.ohlcv_history['low'].astype(float), 
                            self.ohlcv_history['close'].astype(float), 
                            length=self.atr_period)
        
        if atr_series.iloc[-1] is None or pd.isna(atr_series.iloc[-1]): 
            # This can happen if the last ATR value is NaN, which means not enough valid data points.
            # Example: If a candle has NaN in high/low/close.
            # print(f"[{self.symbol}] Warning: ATR is NaN or None. Not enough valid data points for ATR calculation yet. Skipping dynamic grid recalculation.")
            self.grid_levels = [] 
            return

        current_atr = Decimal(str(atr_series.iloc[-1])) 

        if current_atr <= Decimal('0'): # ATR can sometimes be zero if price is perfectly flat, or negative due to data issues.
            # print(f"[{self.symbol}] Warning: ATR is zero or negative ({current_atr}). Skipping dynamic grid recalculation.")
            self.grid_levels = [] 
            return

        total_grid_width = current_atr * self.grid_atr_multiplier
        
        self.grid_lower_bound = current_price_decimal - (total_grid_width / Decimal('2'))
        self.grid_upper_bound = current_price_decimal + (total_grid_width / Decimal('2'))

        if self.grid_lower_bound <= Decimal('0'): 
            self.grid_lower_bound = Decimal('0.000001')

        num_grids = Decimal(str(self.config_params["number_of_grids"])) 
        
        if num_grids <= Decimal('0'):
            # print(f"[{self.symbol}] Warning: Number of grids is zero or negative ({num_grids}). Skipping grid level calculation.")
            self.grid_levels = []
            return
        
        grid_step_size = total_grid_width / num_grids

        if grid_step_size <= Decimal('0'):
            # print(f"[{self.symbol}] Warning: Grid step size is zero or negative ({grid_step_size}). Skipping grid level calculation.")
            self.grid_levels = []
            return

        self.grid_levels = []
        
        # Generate buy orders below current price
        current_grid_price = current_price_decimal - grid_step_size / Decimal('2') 
        
        for i in range(int(num_grids / Decimal('2'))): 
            price = current_grid_price - (grid_step_size * Decimal(str(i)))
            price = price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP) 
            if price >= self.grid_lower_bound: 
                self.grid_levels.append({'price': price, 'type': 'buy', 'status': 'open'})
            else:
                break 

        # Generate sell orders above current price
        current_grid_price = current_price_decimal + grid_step_size / Decimal('2') 
        
        for i in range(int(num_grids / Decimal('2'))): 
            price = current_grid_price + (grid_step_size * Decimal(str(i)))
            price = price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            if price <= self.grid_upper_bound: 
                self.grid_levels.append({'price': price, 'type': 'sell', 'status': 'open'})
            else:
                break 
        
        self.grid_levels.sort(key=lambda x: x['price'])
        
        # print(f"[{self.symbol}] Dynamic Grid Re-calculated: {len(self.grid_levels)} levels. ATR: {current_atr:.2f}, Range: {self.grid_lower_bound:.2f} - {self.grid_upper_bound:.2f}")


    def on_candle(self, symbol, candle_data, current_price_decimal, current_time):
        """
        Called by the Backtester for each new candle. This is the main loop for strategy decisions.
        """
        self.current_price = current_price_decimal 
        
        # Append current candle data to history for ATR calculation
        # Ensure 'open', 'high', 'low', 'close', 'volume' are Decimal for storage
        candle_data_decimal = candle_data.copy()
        for col in ['open', 'high', 'low', 'close', 'volume']:
            candle_data_decimal[col] = Decimal(str(candle_data[col]))

        new_row_df = pd.DataFrame([candle_data_decimal], index=[current_time])
        self.ohlcv_history = pd.concat([self.ohlcv_history, new_row_df])
        
        # Keep only the last 'atr_period' + a buffer for calculation efficiency
        self.ohlcv_history = self.ohlcv_history.iloc[-(self.atr_period + 5):]

        # Recalculate dynamic grid levels on each candle
        self._recalculate_dynamic_grid(current_price_decimal) 
        
        # Re-evaluate and place orders to maintain desired active grid levels
        self._manage_grid_orders()


    def _manage_grid_orders(self):
        """
        Ensures that the `active_buy_orders` and `active_sell_orders` lists
        reflect the desired state of the grid based on `max_concurrent_orders_per_side`
        and current price. This re-places orders after fills on a DYNAMIC grid.
        """

        # Create a set of prices/types of currently active orders to prevent duplicates
        # This reflects orders that were *successfully placed* and are still active.
        active_order_identifiers = set()
        
        # Rebuild active lists based on current grid_levels status and if they were previously executed.
        temp_active_buy_orders = []
        for order in self.active_buy_orders:
            current_level_found = False
            for i, level_in_grid in enumerate(self.grid_levels):
                if level_in_grid['price'].compare(order['price']) == 0 and level_in_grid['type'] == order['type']:
                    if level_in_grid['status'] != 'filled': # If it's not filled, keep it active
                        temp_active_buy_orders.append(order)
                        active_order_identifiers.add((order['price'], order['type'])) # Add to set if truly active
                    current_level_found = True
                    break
            # If the order's level is no longer in the dynamic grid, it's implicitly removed by not re-adding.
            # If current_level_found is False, it means the order's price is no longer part of the grid.

        temp_active_sell_orders = []
        for order in self.active_sell_orders:
            current_level_found = False
            for i, level_in_grid in enumerate(self.grid_levels):
                if level_in_grid['price'].compare(order['price']) == 0 and level_in_grid['type'] == order['type']:
                    if level_in_grid['status'] != 'filled':
                        temp_active_sell_orders.append(order)
                        active_order_identifiers.add((order['price'], order['type'])) # Add to set if truly active
                    current_level_found = True
                    break

        self.active_buy_orders = temp_active_buy_orders
        self.active_sell_orders = temp_active_sell_orders


        # Identify potential buy orders: levels below current price that are 'open'
        potential_buy_levels = []
        for i, level in enumerate(self.grid_levels): 
            if level['type'] == 'buy' and level['price'] < self.current_price and level['status'] == 'open':
                potential_buy_levels.append({'level': level, 'idx': i}) 
        potential_buy_levels.sort(key=lambda x: x['level']['price'], reverse=True) 

        # Place new buy orders up to `max_concurrent_orders_per_side`
        for item in potential_buy_levels:
            level = item['level']
            level_idx = item['idx'] 
            
            # Use the identifier set to prevent duplicate active orders
            if (level['price'], level['type']) in active_order_identifiers:
                continue 

            if len(self.active_buy_orders) >= self.config_params["max_concurrent_orders_per_side"]:
                break 
            
            amount_to_trade = self._calculate_amount_for_order(self.symbol, level['price'])
            if amount_to_trade == Decimal('0'): continue 
            
            required_cash = level['price'] * amount_to_trade * (Decimal('1') + self.commission_rate)
            if self.portfolio['cash'] >= required_cash: 
                # CRITICAL FIX: Only add to active_buy_orders if _execute_order_func is successful
                if self.execute_order_func(self.symbol, 'buy', level['price'], amount_to_trade):
                    self.active_buy_orders.append({
                        'symbol': self.symbol,
                        'type': 'buy',
                        'price': level['price'],
                        'amount': amount_to_trade,
                        'grid_level_idx': level_idx 
                    })
                    self.grid_levels[level_idx]['status'] = 'pending' 
                    print(f"[{self.symbol}] Managing: Placed BUY order @ {level['price']:.2f} for {amount_to_trade:.8f}")
                # else: `_execute_order_func` will log failure if funds are insufficient. Order not added to active list.

        # Identify potential sell orders: levels above current price that are 'open'
        potential_sell_levels = []
        for i, level in enumerate(self.grid_levels): 
            if level['type'] == 'sell' and level['price'] > self.current_price and level['status'] == 'open':
                potential_sell_levels.append({'level': level, 'idx': i}) 
        potential_sell_levels.sort(key=lambda x: x['level']['price']) 

        # Place new sell orders up to `max_concurrent_orders_per_side`
        for item in potential_sell_levels:
            level = item['level']
            level_idx = item['idx'] 

            if (level['price'], level['type']) in active_order_identifiers:
                continue 

            if len(self.active_sell_orders) >= self.config_params["max_concurrent_orders_per_side"]:
                break 
            
            amount_to_trade = self._calculate_amount_for_order(self.symbol, level['price'])
            if amount_to_trade == Decimal('0'): continue 
            
            base_currency = self.symbol.split('_')[0]
            if self.portfolio['crypto_holdings'].get(base_currency, Decimal('0')) >= amount_to_trade: 
                # CRITICAL FIX: Only add to active_sell_orders if _execute_order_func is successful
                if self.execute_order_func(self.symbol, 'sell', level['price'], amount_to_trade):
                    self.active_sell_orders.append({
                        'symbol': self.symbol,
                        'type': 'sell',
                        'price': level['price'],
                        'amount': amount_to_trade,
                        'grid_level_idx': level_idx 
                    })
                    self.grid_levels[level_idx]['status'] = 'pending' 
                    print(f"[{self.symbol}] Managing: Placed SELL order @ {level['price']:.2f} for {amount_to_trade:.8f}")
                # else: `_execute_order_func` will log failure if funds are insufficient. Order not added to active list.


    def notify_order_filled(self, filled_order):
        """
        Called by the backtester when an order is filled.
        Updates the strategy's internal state and re-arms the grid for a DYNAMIC grid.
        It finds the *current* index of the filled order within the *current* grid_levels.
        """
        symbol = filled_order['symbol']
        order_type = filled_order['type']
        filled_price = filled_order['price']
        
        # Find the *current* index of the filled_price in the *current* grid_levels
        current_level_idx = -1
        for i, level in enumerate(self.grid_levels):
            # Using compare(0) for exact Decimal equality due to floating point nuances
            if level['price'].compare(filled_price) == 0 and level['type'] == order_type: 
                current_level_idx = i
                break

        if current_level_idx != -1:
            self.grid_levels[current_level_idx]['status'] = 'filled'
            
            # Re-arm the corresponding opposite order on the DYNAMIC grid.
            # This logic now explicitly looks for the opposite type at a nearby level.
            # If a BUY at Level N fills, re-enable the SELL level just above it (Level N+X).
            # If a SELL at Level N fills, re-enable the BUY level just below it (Level N-X).
            
            if order_type == 'buy':
                # Iterate upwards from the filled level's current index
                corresponding_sell_level_found = False
                for i in range(current_level_idx + 1, len(self.grid_levels)):
                    level_to_rearm = self.grid_levels[i]
                    if level_to_rearm['type'] == 'sell': # We are looking for a sell level
                        # If this sell level was previously 'filled' (meaning it was sold), we re-open it.
                        # Also, ensure it's not currently pending to avoid re-adding an order still in play.
                        if level_to_rearm['status'] == 'filled': 
                            level_to_rearm['status'] = 'open' 
                            corresponding_sell_level_found = True
                            break
                if not corresponding_sell_level_found:
                    pass # Warning is fine, grid might be out of range, or no higher sell levels.


            elif order_type == 'sell':
                # Iterate downwards from the filled level's current index
                corresponding_buy_level_found = False
                for i in range(current_level_idx - 1, -1, -1): 
                    level_to_rearm = self.grid_levels[i]
                    if level_to_rearm['type'] == 'buy': # We are looking for a buy level
                        if level_to_rearm['status'] == 'filled': 
                            level_to_rearm['status'] = 'open' 
                            corresponding_buy_level_found = True
                            break
                if not corresponding_buy_level_found:
                    pass # Warning is fine, grid might be out of range, or no lower buy levels.
        else:
            # This can happen if a filled order's level is no longer in the dynamic grid
            # (e.g., grid shifted significantly) or if its status was already updated.
            pass


# Example usage (for testing purposes only, not part of actual bot run)
if __name__ == "__main__":
    from config.parameters import GRID_STRATEGY_PARAMS, INITIAL_BACKTEST_CAPITAL, COMMISSION_RATE
    from config.settings import KRAKEN_MIN_ORDER_SIZES
    
    mock_portfolio = {
        'cash': Decimal(str(INITIAL_BACKTEST_CAPITAL)),
        'crypto_holdings': {},
        'open_orders': []
    }
    
    mock_min_order_sizes = {
        'BTC': Decimal('0.0001'), 'ETH': Decimal('0.005'), 'SOL': Decimal('0.1'), 'ADA': Decimal('1.0'), 
        'DOT': Decimal('1.0'), 'AVAX': Decimal('0.1'), 'ATOM': Decimal('1.0'), 'LINK': Decimal('1.0'), 'XRP': Decimal('10.0')
    }

    def mock_execute_order(symbol, order_type, price, amount):
        print(f"MOCK EXECUTE: {order_type.upper()} {amount:.8f} {symbol.split('_')[0]} @ {price:.2f}")
        base_currency = symbol.split('_')[0]
        cost = price * amount
        commission = cost * Decimal(str(COMMISSION_RATE))

        if order_type == 'buy':
            if mock_portfolio['cash'] >= cost + commission:
                mock_portfolio['cash'] -= (cost + commission)
                mock_portfolio['crypto_holdings'][base_currency] = mock_portfolio['crypto_holdings'].get(base_currency, Decimal('0')) + amount
                return True
            else:
                print(f"MOCK EXECUTE FAILED (BUY): Insufficient cash for {amount:.8f} {symbol} @ {price:.2f}")
                return False
        elif order_type == 'sell':
            revenue = price * amount
            commission = revenue * Decimal(str(COMMISSION_RATE))
            if mock_portfolio['crypto_holdings'].get(base_currency, Decimal('0')) >= amount:
                mock_portfolio['cash'] += (revenue - commission)
                mock_portfolio['crypto_holdings'][base_currency] -= amount
                return True
            else:
                print(f"MOCK EXECUTE FAILED (SELL): Insufficient crypto for {amount:.8f} {symbol} @ {price:.2f}")
                return False
        return False

    # Test for BTC_USD
    btc_params = GRID_STRATEGY_PARAMS.copy()
    btc_params["symbol"] = "BTC_USD" 
    
    strategy = GridStrategy(btc_params)
    strategy.set_backtester_context(mock_portfolio, mock_execute_order, COMMISSION_RATE, mock_min_order_sizes)

    initial_btc_price = Decimal('85000.0') 
    strategy.current_price = initial_btc_price 

    # For dynamic grid, need to feed initial candles for ATR calculation
    dummy_ohlcv_data = []
    for _ in range(strategy.atr_period + 5): 
        dummy_ohlcv_data.append({
            'open': initial_btc_price, 
            'high': initial_btc_price * Decimal('1.001'), 
            'low': initial_btc_price * Decimal('0.999'), 
            'close': initial_btc_price, 
            'volume': Decimal('100')
        })
    strategy.ohlcv_history = pd.DataFrame(dummy_ohlcv_data)
    strategy.ohlcv_history.index = pd.to_datetime(range(len(strategy.ohlcv_history)), unit='s')


    strategy._place_initial_orders() 

    print("\n--- Simulating a few candles manually for strategy testing ---")
    
    print("\nSimulating first real candle (within grid range)...")
    first_candle_data = {
        'open': initial_btc_price,
        'high': initial_btc_price * Decimal('1.001'),
        'low': initial_btc_price * Decimal('0.999'),
        'close': initial_btc_price,
        'volume': Decimal('100')
    }
    strategy.on_candle("BTC_USD", pd.Series(first_candle_data), initial_btc_price, datetime.now())

    print("\nSimulating Price drop to trigger a buy...")
    candle_drop_price = Decimal('84500.0') 
    mock_candle_data = {
        'open': initial_btc_price,
        'high': initial_btc_price,
        'low': candle_drop_price,
        'close': candle_drop_price,
        'volume': Decimal('100')
    }
    strategy.on_candle("BTC_USD", pd.Series(mock_candle_data), candle_drop_price, datetime.now() + timedelta(minutes=1))

    print("\nSimulating Price rise to trigger a sell...")
    candle_rise_price = Decimal('85500.0')
    mock_candle_data_rise = {
        'open': candle_drop_price,
        'high': candle_rise_price,
        'low': candle_drop_price,
        'close': candle_rise_price,
        'volume': Decimal('100')
    }
    strategy.on_candle("BTC_USD", pd.Series(mock_candle_data_rise), candle_rise_price, datetime.now() + timedelta(minutes=2))


    print("\n--- Final active orders after manual simulation ---")
    print(f"Active Buy Orders: {len(strategy.active_buy_orders)}")
    for order in strategy.active_buy_orders:
        print(f"  BUY @ {order['price']:.2f}")
    print(f"Active Sell Orders: {len(strategy.active_sell_orders)}")
    for order in strategy.active_sell_orders:
        print(f"  SELL @ {order['price']:.2f}")

    print("\n--- Mock Grid Levels Status (first 5 levels) ---")
    for i, level in enumerate(strategy.grid_levels[:5]):
        print(f"Level {i}: Price={level['price']:.2f}, Type={level['type']}, Status={level['status']}")



